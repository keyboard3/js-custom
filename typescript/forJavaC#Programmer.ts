/**
 * ***** 重新思考 *******
 *  C# 和 Java 强制 OOP 语言中，类是代码组织的基本单位，也是运行时所有数据和行为的基本容器
 * 对于某些问题，强制所有功能和数据都保存在类中可能是一个很好的领域模型，但并非每个领域都需要以这种方式表示
 *
 * ”自由函数和数据“
 *  在 JS 中，函数可以存储于任何地方，数据可以自由传递，无需在预定义 class 或 struct。这种灵活性非常强大
 * 在没有隐含 OOP 层次结构的情况下处理数据的”自由“函数（那些与类无关的函数）往往是 JS 编写程序的首选模型
 *
 * TS 对类型的理解实际上与 C# 和 Java 有很大不同
 *
 *  ”名义具体化类型系统“
 *  在 C# 或 Java 中，任何给定的值或独享都有一个确切的类型- null 原始类型或已知的类类型。我们可以在运行时调用类似
 * value.GetType() 或 Value.getClass() 来查询确切的类型。这种类型的定义将驻留在某个具有某个名称的类中，
 * 除非存在显式继承关系或通用实现的接口，否则我们不能使用具有相似形状的两个类来代替彼此。
 *  这些方面描述了具体化的、名义上的类型系统。我们在代码中编写的类型在运行时存在，并且这些类型通过它们的声明而不是它们
 * 的结构相关联
 * 
 * ”类型作为集合“
 *  在 C# 或 Java 中，考虑运行时类型与其编译时声明之间的一一对应关系是有意义的
 *  在 TypeScript 中，最好将类型视为一组具有相同点的值。因为类型只是集合，一个特定的值可以同时属于多个集合
 *  一旦您开始将类型视为集合，某些操作就会变得非常自然。例如，在 C# 中，无法做到一个值可以是 string 或 int,
 * 因为没有一个单一的类型表示它。
 *  TypeScript 提供了许多以集合论方式处理类型的机制，如果你将类型视为集合，你会发现它更直观
 */

/**
 * ”擦除的结构类型“
 *  在 TS 中，对象不是单一的精确类型。例如，如果我们构造一个满足接口的对象，即使两者之间没有声明关系，我们也可以在需要
 * 该接口的地方使用该对象
 */
interface Pointlike {
  x: number;
  y: number;
}
interface Named {
  name: string;
}

function logPoint(point: Pointlike) {
  console.log("x = " + point.x + ", y = " + point.y);
}

function logName(x: Named) {
  console.log("Hello, " + x.name);
}

const obj = {
  x: 0,
  y: 0,
  name: "Origin",
};
/**
 *  TS 的类型系统是结构性的，而不是名义上的：我们可以将其 obj 用作 a, Pointlike 因为它的 x 和 y 属性都是数字。
 * 类型之间的关系由他们包含的属性决定，而不是它们以某种特定关系声明。
 *  TS 的类型系统也没有具体化：在运行时没有任何东西可以告诉我们这 obj 是 Pointlike。事实上，该 Pointlike 类型在运行时
 * 不以任何形式存在。
 */
logPoint(obj);
logName(obj);

/**
 * ”反射“
 *  OOP 程序员习惯于能够查询任何值的类型，甚至是泛型
 *  但是 TS 不行，因为 TS 的类型系统被完全擦除，所以有关例如泛型类型参数实例化的信息在运行时不可用。
 *  JS 确实有些有限的原语，例如 typeof 和 instanceof, 但请记住，这些运算符仍在处理类型擦除输出代码中存在的值。
 * 如 typeof (new Car()) 是 "object", 而不是 Car 或 "Car"
 */